(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{68:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return u}));var a=n(2),r=n(6),o=(n(0),n(86)),i={id:"basic",title:"Quick-start  guide",sidebar_label:"Quick-start guide"},c={unversionedId:"start/basic",id:"start/basic",isDocsHomePage:!1,title:"Quick-start  guide",description:"Using VecPy is about as easy as using NumPy, except that you need to transfer results to and from",source:"@site/docs/start/basic.md",permalink:"/vecpy/docs/start/basic",editUrl:"https://github.com/ooreilly/vecpy/docs/start/basic.md",sidebar_label:"Quick-start guide",sidebar:"API",previous:{title:"Installation",permalink:"/vecpy/docs/start/installation"},next:{title:"elementwise",permalink:"/vecpy/docs/api/elementwise"}},s=[{value:"Summation",id:"summation",children:[]},{value:"Elementwise computation",id:"elementwise-computation",children:[]},{value:"Shapes",id:"shapes",children:[]},{value:"Functions",id:"functions",children:[]}],p={rightToc:s};function u(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Using VecPy is about as easy as using NumPy, except that you need to transfer results to and from\nthe GPU. This section demonstrates the basic usage and features of VecPy by computing the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Pythagorean_trigonometric_identity"}),"Pythagorean\ntrigonometric identity")," for each element in a vector ",Object(o.b)("inlineCode",{parentName:"p"},"u"),"."),Object(o.b)("h3",{id:"summation"},"Summation"),Object(o.b)("p",null,"Since the Pythagorean trigonometric identity is equal to one for any angle, if you apply this\nidentity to each element in the vector ",Object(o.b)("inlineCode",{parentName:"p"},"u")," and sum the result you must get the length of the vector\nback. Here is how to implement and check this property in vecpy."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-py"}),">>> import numpy as np\n>>> import vecpy as vp\n>>> n = 1000\n>>> u = np.random.rand(n)\n>>> vu = vp.to_vecpy(u)\n>>> sum = vp.sum(vp.cos(vu)**2 + vp.sin(vu)**2)\n>>> sum.get()\narray([1000.])\n")),Object(o.b)("p",null,"The function ",Object(o.b)("inlineCode",{parentName:"p"},"to_vecpy()")," allocates  a new array of the same shape and type as ",Object(o.b)("inlineCode",{parentName:"p"},"u")," on the device and copies its values.\nMake sure to call the method ",Object(o.b)("inlineCode",{parentName:"p"},"get()"),"to transfer the result from the device to the host. Note that\nthe call ",Object(o.b)("inlineCode",{parentName:"p"},"sum.get()")," returned  ",Object(o.b)("inlineCode",{parentName:"p"},"array([1000.])"),", which is the length of ",Object(o.b)("inlineCode",{parentName:"p"},"u")," but as a floating-point number. This is because VecPy performed the accumulation using double precision."),Object(o.b)("h3",{id:"elementwise-computation"},"Elementwise computation"),Object(o.b)("p",null,"Unlike Numpy, no computation takes place if you only write the expression ",Object(o.b)("inlineCode",{parentName:"p"},"vp.cos(vu)**2 + vp.sin(vu)**2"),". If you want to perform the elementwise computation of this expression and place the result in a new array, you need to explicitly state that. "),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-py"}),">>> vr = vp.elementwise(vp.cos(vu)**2 + vp.sin(vu)**2)\n>>> vr.get()\narray([1., 1., 1., 1., 1., 1., ... 1.])\n")),Object(o.b)("p",null,"Note that the function call ",Object(o.b)("inlineCode",{parentName:"p"},"vp.elementwise")," will allocate a new array for you. If you want to reuse\nan old array you can do so as well. "),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-py"}),">>> vr = vp.zeros_like(u)\n>>> vp.elementwise(vp.cos(vu)**2 + vp.sin(vu)**2, out=r)\n>>> vp.elementwise(vp.cos(vu)**2 + vp.sin(vu)**2, out=r)\n>>> vr.get()\narray([1., 1., 1., 1., 1., 1., ... 1.])\n")),Object(o.b)("h3",{id:"shapes"},"Shapes"),Object(o.b)("p",null,"The shape of the array does not matter as long as all arrays have the same shape."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-py"}),">>> A = np.ones((n, n))\n>>> vA = vp.to_vecpy(A)\n>>> sum = vp.sum(vA)\n>>> sum.get()\narray([1000000.])\n")),Object(o.b)("h3",{id:"functions"},"Functions"),Object(o.b)("p",null,"If you encounter a situation in which a math\nfunction you need is not implemented, you can implement it yourself as a work-around (as long as it\nis part of the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.nvidia.com/cuda/cuda-math-api/index.html"}),"CUDA Math library"),"). For example,\nhere is how to implement the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Gamma_function"}),"Gamma")," function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-py"}),'>>> gamma = lambda x : vp.function("tgamma", x)\n>>> vy = vp.elementwise(gamma(u))\n\n')))}u.isMDXComponent=!0},86:function(e,t,n){"use strict";n.d(t,"a",(function(){return l})),n.d(t,"b",(function(){return d}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=r.a.createContext({}),u=function(e){var t=r.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},l=function(e){var t=u(e.components);return r.a.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),l=u(n),b=a,d=l["".concat(i,".").concat(b)]||l[b]||m[b]||o;return n?r.a.createElement(d,c(c({ref:t},p),{},{components:n})):r.a.createElement(d,c({ref:t},p))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=b;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var p=2;p<o;p++)i[p]=n[p];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);